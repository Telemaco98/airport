THEORY ProofList IS
_f(1) & _f(2) & ValuesLemmas.8,(_f(3) => _f(11));
_f(1) & _f(2) & ValuesLemmas.7,(_f(3) => _f(10));
_f(1) & _f(2) & ValuesLemmas.6,(_f(3) => _f(9));
_f(1) & _f(2) & ValuesLemmas.5,(_f(3) => _f(8));
_f(1) & _f(2) & ValuesLemmas.4,(_f(3) => _f(7));
_f(1) & _f(2) & ValuesLemmas.3,(_f(3) => _f(6));
_f(1) & _f(2) & ValuesLemmas.2,(_f(3) => _f(5));
_f(1) & _f(2) & ValuesLemmas.1,(_f(3) => _f(4))
END
&
THEORY Formulas IS
((NAT) = (((0) .. (2147483647)))) & ((INT) = (((-2147483647) .. (2147483647))));
((1..6)*{STATUS}): FIN(NATURAL*{STATUS}) & not(((1..6)*{STATUS}) = {}) & ((1..6)*{STATUS}): FIN(NATURAL*{STATUS}) & not(((1..6)*{STATUS}) = {}) & ((1..6)*{STATUS}): FIN(NATURAL*{STATUS}) & not(((1..6)*{STATUS}) = {}) & ((1..6)*{STATUS}): FIN(NATURAL*{STATUS}) & not(((1..6)*{STATUS}) = {}) & ((1..6)*{STATUS}): FIN(NATURAL*{STATUS}) & not(((1..6)*{STATUS}) = {}) & ((1..6)*{STATUS}): FIN(NATURAL*{STATUS}) & not(((1..6)*{STATUS}) = {}) & ((1..2)*{OCCUPATION}): FIN(NATURAL*{OCCUPATION}) & not(((1..2)*{OCCUPATION}) = {}) & ((1..2)*{OCCUPATION}): FIN(NATURAL*{OCCUPATION}) & not(((1..2)*{OCCUPATION}) = {});
"Valuation is correct";
((100) : ((NAT-{0})));
(1 +1 <= 100);
((5) : ((NAT-{0})));
(1 +1 <= 5);
((1000) : ((NAT-{0})));
(1 +1 <= 1000);
((1000) : (((0) .. (1000))));
((0) .. (1000)): FIN(INTEGER) & not(((0) .. (1000)) = {});
AIRPLANE: FIN(INTEGER) & not(AIRPLANE = {}) & ((1..6)*{STATUS}): FIN(NATURAL*{STATUS}) & not(((1..6)*{STATUS}) = {}) & ((1..2)*{OCCUPATION}): FIN(NATURAL*{OCCUPATION}) & not(((1..2)*{OCCUPATION}) = {}) & ((sz_gates) : ((NAT-{0}))) & (1 +1 <= sz_gates) & ((sz_tracks) : ((NAT-{0}))) & (1 +1 <= sz_tracks) & ((sz_airplanes) : ((NAT-{0}))) & (1 +1 <= sz_airplanes) & ((gate) = (((0) .. (sz_gates)))) & ((track) = (((0) .. (sz_tracks)))) & ((plane_dummy) : (AIRPLANE));
((sz_gates) = (100)) & ((sz_tracks) = (5)) & ((sz_airplanes) = (1000)) & ((gate) = (((0) .. (sz_gates)))) & ((track) = (((0) .. (sz_tracks)))) & ((AIRPLANE) = (((0) .. (sz_airplanes)))) & ((plane_dummy) = (1000));
btrue
END
&
THEORY EnumerateX IS
OCCUPATION == {occupied,unoccupied};
STATUS == {out,flighting,alighting,parked,boarding,departing}
END
